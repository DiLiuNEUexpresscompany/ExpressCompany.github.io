<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content>
  <meta name="author" content="Express Company">
  <!-- Open Graph Data -->
  <meta property="og:title" content="廖雪峰Git常用语法摘要">
  <meta property="og:description" content="整点新鲜的">
  <meta property="og:site_name" content="一把老剑条的Blog">
  <meta property="og:type" content="article">
  <meta property="og:image" content="https://expresscompany.github.io">
  
    <link rel="alternate" href="/atom.xml" title="一把老剑条的Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>一把老剑条的Blog</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">廖雪峰Git常用语法摘要</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/ExpressCompany">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:1721318030@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Express Company</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2019-10-08</span>
            <span class="time">22:25:45</span>
          </span>
          
        </div>
        <!-- Tags -->
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>date: 2019-10-08 16:04:00</p>
<p>tags:<br>     Git<br>     Github</p>
<hr>
<p>一、Git简介</p>
<p>Git是当前最为流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub。在项目开发中使用Git版本管理系统不仅十分便捷，而且对整个项目开发流程具有十分重要的意义。</p>
<p>二、安装Git</p>
<p>Windows系统需下载，Mac系统因为自带Git无需操作。</p>
<p>下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p>
<p>测试安装：<code>git --version</code>，查看显示版本号即成功。</p>
<p>三、创建版本库</p>
<p>命令: </p>
<p><code>mkdir learntGit</code>        在当前目录下创建learntGit文件夹</p>
<p><code>cd  learnGit</code>           进入learnGit文件夹中</p>
<p><code>pwd</code>                    查看当前路径</p>
<p><code>git init</code>               将当前目录变成Git可以管理的仓库</p>
<p><code>git add + 文件名</code>        将文件添加到仓库，可多次提交（添加成功，没有任何显示）</p>
<p><code>git commit -m + 提交说明</code>  把文件提交到版本库</p>
<p>示例: 提交3个文件到版本库中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git  add  file1.txt</span><br><span class="line"></span><br><span class="line">git  add  file2.txt  file3.txt</span><br><span class="line"></span><br><span class="line">git  commit -m  “add 3 files”</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<p>1.图片，视频是二进制文件，Git只知到大小变化，不能跟踪具体变化</p>
<p>2.Microft的word格式也是二进制格式</p>
<p>3.添加文件到Git仓库，分两步：</p>
<p>第一步：使用命令 <code>git add &lt;file&gt;</code>,注意，可反复多次使用，添加多个文件</p>
<p>第二步：使用 <code>it commit</code>，完成</p>
<p>四、Git开发常用命令</p>
<p>1.查看版本状态</p>
<p>命令: </p>
<p><code>git  status</code>  查看当前版本库的状态</p>
<p><code>git  diff</code>   查看当前相对上一次提交修改的内容</p>
<p>2.版本回退</p>
<p>命令: </p>
<p><code>git log</code>                         显示从最近到最远的提交日志</p>
<p><code>git log   --pretty== oneline</code>    显示log,但是不显示很多凌乱的信息</p>
<p><code>q</code>                              显示log版本信息有很多，使用q键停止查看</p>
<p><code>git reset —hard head^</code>        回退到上一个版本</p>
<p><code>git reset —hard head^^</code>       回退到上上个版本</p>
<p><code>git reset —hard head~100</code>     回退到之前100个版本</p>
<p><code>git reset —hard +commit_id</code>    回到某个版本号的版本</p>
<p>问题说明：版本回退过多，想仍然使用被回退掉的最新版本</p>
<p>情况一：曾经查看过log, 当前的命令窗口并未关闭，找到原来的版本号，使用如下命令恢复：</p>
<p><code>git reset — hard 版本号</code></p>
<p>情况二：命令行已经关闭，不知道原来的版本号。使用git reflog查看曾经使用过的命令，曾经回退版本的时候会在这里显示版本号，然后继续使用情况一中的方法，恢复版本。</p>
<p>小结：</p>
<p>使用<code>git log</code>我们可以看到一大串的commit id(版本号), 这不同于SVN的版本号(递增的数字),Git的版本号是SHA1计算出来的一个非常大的数字，防止分布式系统开发版本号冲突。</p>
<p>3.工作区与暂存区</p>
<p>工作区是我们在电脑里看到的目录，比如一个文件夹。工作区有一个隐藏目录.git，这个是Git的版本库。Git版本库里存很多东西，最重要的是暂存区(stage或者index)。Git为我们自动创建第一个分支master,以及master的一个指针叫做HEAD。</p>
<p><code>git  add</code>   :  添加文件，是将文件修改添加到暂存区。</p>
<p><code>git commit</code>:  提交更改，实际是把暂存区的所有内容提交到当前分支</p>
<p>一但提交之后，如果你又没有对工作区有新的修改，那么工作区是clean的</p>
<p>4.管理修改</p>
<p>问题说明:</p>
<p>我们修改一个文件，第一次修改之后执行<code>git add</code> ，第二次修改不执行<code>git add</code> ,然后我们执行<code>git commit</code>并使用<code>git status</code>查看状态，可以发现第二次的修改并未提交。这是因为Git跟踪修改，如果不add到暂存区就不会加入到commit。</p>
<p>解决方案：继续执行<code>git add</code>，再<code>git commit</code>，也可以别着急提交第一次修改，先add第二次修改再commit</p>
<p>5.撤销修改</p>
<p>情况一: 文件修改后还没被放到暂存区，</p>
<p>情况二: 文件修改后已经被添加到暂存区，然后又做了修改。又修改部分被撤销，</p>
<p>解决方案：</p>
<p><code>git checkout --  + 文件名</code>   将文件在工作区的修改全部撤销。</p>
<p>执行结果:</p>
<p>情况一：执行撤销就回到和版本库一模一样的状态。</p>
<p>情况二：文件会恢复到上次添加到暂存区的状态，即使多次使用也只能回到最近一次暂存区状态。</p>
<p>情况一和情况二，总之都是让文件回到最近一次git commit或者add时的状态</p>
<p>情况三：想要撤销的部分已经add到暂存区，但是还没有被commit</p>
<p>解决方案：</p>
<p>1.使用<code>git reset HEAD +文件名</code>   把暂存区的修改撤销，重新放回到工作区。</p>
<p>2.根据情况1和情况2的方法撤销修改</p>
<p>情况四：想要撤销的部分已经提交到版本库中，但是还没有push到远程仓库</p>
<p>解决方法：使版本回退的方法</p>
<p>小结：<code>git check</code>的 “—” 很重要，没有“—“, 该命令就变成了切换分支的命令(双横杠)</p>
<p>6.删除文件</p>
<p>命令： <code>rm + 文件名</code>   删除文件</p>
<p>分析问题：</p>
<p>修改一个文件，使用add、commit将其添加到版本库中，然后又在文件管理器中删除了此文件。这时就会使工作区和版本库不一致了。</p>
<p><code>git status</code>会告诉那些文件被删除。这时候处理方法有两种：</p>
<p>选择1：</p>
<p>确实要从版本库中删除该文件，使用<code>git rm +文件名</code> 然后<code>commit</code>,</p>
<p>文件就从版本库中删除了</p>
<p>选择2：</p>
<p>其实是删错了。因为版本库中还有，可以将误删文件恢复到最新版本,</p>
<p>但是最近一次提交之后修改的内容丢失了。这里使用的命令是：</p>
<p><code>git check --  +文件名</code></p>
<p>小结：<code>git checkout</code>其实是使用版本库中版本替换工作区版本，无论修改还是删除都可以”一键还原”</p>
<p>五、远程仓库</p>
<p>1.本地仓库与远程仓库之间的传输设置</p>
<p>本地仓库Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要一点设置：</p>
<p>第一步：创建SSH Key。</p>
<p>1.在用户的主目录下，查看是否有.ssh目录.</p>
<p>2.如果有，再看看这个目录有没有 id_rsa和id_rsa.pub这两个文件。</p>
<p>3.如果有，可直接跳到下一步。</p>
<p>4.如果没有，打开Shell(Window下打开Git Bash),创建SSH Key。</p>
<p>5.使用命令创建SSH Key：<code>ssh -keygen -t rss -C  + github邮箱地址</code></p>
<p>第二步：设置远程仓库的key(以GitHub为例)</p>
<p>1.登陆GitHub，打开“Account Setting” -&gt;“SSH Keys”页面。</p>
<p>2.点击”Add SSH Key”, 填上任意Title, 在key文本框中粘贴id_rsa.pub文件的内容。</p>
<p>3.点击”Add key”，确认添加了公钥</p>
<p>小结：</p>
<p>1.id_rsa是私钥，不能泄露出去；id_rsa.public是公钥，可以放心的告诉任何人。</p>
<p>2.GitHub通过SSH Key加密，是为了识别是否为真用户的提交。</p>
<p>3.GitHub允许添加多个key,将多台电脑的Key添加到GitHub，就可以在每台电脑上推送了</p>
<p>4.创建key的时候，key并不是很重要，可以不设置密码</p>
<p>2.将本地仓库与远程仓库关联同步</p>
<p>命令: </p>
<p><code>git remote add origin +远程仓库地址</code>   将本地仓库关联远程仓库</p>
<p><code>git push -u origin master</code>          第一次推送master分支的所有内容到远程仓库</p>
<p><code>git push origin master</code>             本地推送到远程(第一次之后）</p>
<p>小结: 要关联一个远程仓库，使用命令 “<code>git remote add origin + 远程仓库地址</code>”，</p>
<p>关联之后使用命令 “<code>git push -u origin master</code>” 第一次推送master分支的所有内容。</p>
<p>每次本地提交之后，只要有必要就可以使用命令git push origin master推送最新修改。</p>
<p>3.从远程仓库克隆文件到本地</p>
<p>命令: </p>
<p><code>git clone +远程仓库地址</code>   克隆远程仓库到本地，相当于创建了与之关联的本地仓库</p>
<p>示例: </p>
<p>先使用cd命令切换到某个文件夹位置然后使用如下命令:</p>
<p><code>git  clone git@github.com:DreamcoffeeZS/Demo_FDTemplateLayoutCell.git</code></p>
<p>小结:</p>
<p>1.克隆仓库，首先要知道仓库地址(查看GitHub)，然后使用git clone命令克隆。</p>
<p>2.Git支持多种协议，包括https，但是通过ssh支持的原生git协议速度更快。</p>
<p>3.执行该命令成功后，本地就会出现于远程仓库相关联的本地仓库，可以track远程仓库的变化</p>
<p>六、分支管理</p>
<p>1.理解概念：</p>
<p>a. 主分支(默认分支)，代表版本commit的形成的时间线</p>
<p>b. <code>HEAD</code>指针指向master分支，master指针指向版本库commit的最新位置</p>
<p>c. 每次commit，master指针会向前移动一步，随着不断提交，master分支线越来越长。</p>
<p>d. 每次创建新的分支，如dev分支，Git会创建新的分支指针dev，然后将dev指针指向与master指针相同的提交位置，再将HEAD指针指向dev，表明当前分支是dev。</p>
<p>e. 合并分支其实就是改变原来分支指针的指向。合并之后可以删除无用的分支</p>
<p>2.创建与合并分支</p>
<p>命令: </p>
<p><code>git  checkout  +  分支名</code>       切换分支</p>
<p><code>git  checkout  -b  dev</code>      git checkout命令加上-b参数表示创建并切换分支</p>
<p><code>git  branch</code>               查看当前分支,会显示所有分支，并在当前分支前加*号</p>
<p><code>git  merge  +  分支名</code>        合并分支，指定分支名的分支合并到当前分支。</p>
<p><code>git  branch +  分支名</code>         创建分支</p>
<p><code>git  branch  -d  + 分支名</code>       删除指定分支名的分支</p>
<p>小结：</p>
<p>1.Git创建、合并、删除分支都非常快，因为只是改变了指针的位置。</p>
<p>2.Git鼓励使用分支完成某个任务，合并分支后再删掉分支，这和直接在master分支上工作一样，但是更安全。</p>
<p>3.解决分支冲突</p>
<p>问题说明：</p>
<p>在dev分支和master分支上修改同一个地方的内容，并且在各自分支上commit。然后在将dev分支合并到master分支时，会发生冲突。</p>
<p>问题分析:</p>
<p>1.发生冲突的时候，使用<code>git status</code>可查看哪些冲突文件</p>
<p>2.Git用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;在冲突文件中标记记出不同分支的内容。</p>
<p>解决方案:</p>
<p>1.在文件冲突的位置，取舍不同分支的修改，确定最终结果。然后执行add和commit。</p>
<p>2.然后用带参数的git log 可以查看分支合并情况，如：</p>
<p><code>git log -- graph -- pretty==online --abbrev-commit</code></p>
<p>3.最后是删除dev分支</p>
<p>小结：<code>git log -- graph</code>命令可以查看分支合并图</p>
<p>4.分支管理策略</p>
<p>问题说明：</p>
<p>对于分支合并，通常的情况我们直接使用git merge命令进行合并，这些都是Fast Forward模式的快速合并。这种合并的缺点在于删除分支之后会丢失分支的信息。</p>
<p>问题分析：</p>
<p>强制禁用Fast forward 模式的合并。Git会在merge时生成一个新的commit，这样从分支历史就可以看出分支信息，禁用时需要使用—- no-ff参数。</p>
<p>示例说明：</p>
<p>在执行合并时的禁用Fast forward的一个示例如下：</p>
<p><code>git merge --no-ff -m “合并分支生成新的commit” dev</code></p>
<p>分支策略：</p>
<p>在实际开发中，我们需要遵循的几个基本原则</p>
<p>1.master分支应该是稳定的，仅用来发布版本，平时不能在上面干活</p>
<p>2.dev分支是我们工作的分支，dev分支不稳定，在版本发布时再将dev分支合并到master分支</p>
<p>3.开发期间每个人都在dev分支上干活，每个人都有自己的分支，时不时的往dev分支合并就好了</p>
<p>5.Bug分支之stash</p>
<p>问题说明：</p>
<p>当前正在dev分支上工作，工作未完无法提交，但是又出现十分紧急的bug需要解决。可以使用stash功能，将当前的工作现场“储藏”起来。等以后恢复现在后继续工作。</p>
<p>命令: </p>
<p><code>git stash</code>                  将当前的工作现场“储藏”起来，此时查看status，</p>
<pre><code>工作区是干净的，可以放心创建分支修改bug</code></pre><p><code>git stash list</code>             查看当前储藏区列表</p>
<p><code>git stash apply</code>            恢复储藏区，但是stash内容并不删除</p>
<p><code>git stash drop</code>             删除储藏区内容</p>
<p><code>git stash pop</code>              恢复储藏区内容并删除内容，再使用git stash list不能看到删除的stash</p>
<p><code>git stash apply stash@{0}</code>   多次stash，恢复时候，先用git stash list查看编号，再执行stash恢复</p>
<p>小结：</p>
<p>1.修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>2.当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p>
<p>6.Feature分支</p>
<p>问题说明：</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>如果需要丢弃一个没有被合并的分支，我们可以强行删除</p>
<p>命令：<code>git branch -D &lt;分支名&gt;</code>  强制删除分支</p>
<p>7.多人协作</p>
<p>理解概念：从远程仓库克隆，实际上Git自动把本地master分支和远程master分支对应起来，并且远程仓库名默认是origin</p>
<p>命令: </p>
<p><code>git remote</code>                                 查看远程仓库信息</p>
<p><code>git remote -v</code>                               查看远程仓库更详细信息;</p>
<pre><code>显示了可以抓取和推送的origin地址，无推送权限时看不到push地址</code></pre><p><code>git push origin master</code>                 推送分支: 将本地master分支推送到对应的远程master分支上</p>
<p><code>git push origin dev</code>                  推送分支: 将本地dev分支推送到对应的远程dev分支上</p>
<p><code>it checkout -b +分支名 origin/分支名</code>   在本地创建和远程分支对应的分支</p>
<p><code>git pull</code>                             把当前分支对应的远程分支上的内容拉取下来</p>
<p><code>git branch —-set-upstream +分支名 origin/分支名</code>   建立本地分支和远程分支的关联 </p>
<p>操作说明:</p>
<p>1.master分支是主分支，会因此要时刻与远程同步</p>
<p>2.dev分支是开发分支，团队所有成员都需要在上面工作，所以也要与远程同步</p>
<p>3.bug分支只用于本地修复bug，没必要推送远程，除非老板需要看你每周到底修改了几个bug</p>
<p>4.feature分支是否推送到远程，取决于你是否和同事合作在上面开发</p>
<p>5.多人协作开发时，大家会在master和dev分支上推送各自的修改</p>
<p>6.在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p>
<p>7.从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<p>小结：</p>
<p>1.协作开发时，两个人修改的同一个文件，各自从本地推送可能会提示冲突。解决方法是，先git pull,再把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。</p>
<p>2.在dev分支上开发，就必须创建远程origin的dev分支到本地</p>
<p>3.如果pull失败，说明没有指定本地的dev分支与远程分支origin/dev分支链接，根据提示，设置dev和origin/dev的链接关系：</p>
<p><code>git branch —-set-upstream dev origin/dev</code> ,然后再次pull</p>
<p>七、标签管理</p>
<p>理解标签:</p>
<p>1.Git的标签是版本库的快照，实际上是指向某个commit的指针，只不过它不想分支指针那样可以移动。</p>
<p>2.标签的作用是帮助我们快速的找到某个时候的版本，常用于开发到每个阶段时设置的开发版本标签(tag)。</p>
<p>命令：</p>
<p><code>git tag  + &lt;tag名&gt;</code>            创建一个标签</p>
<p><code>git tag</code>                        查看所有标签</p>
<p><code>git tag  + &lt;tag名&gt; + commitID</code>   通过git log查看提交过的版本Id,可以为曾经某个commit时刻的版本打上标签</p>
<p><code>git show + &lt;tagname&gt;</code>            查看标签信息，可以看到tag的说明（如果创建的时候带有说明），可以看到PGP签名信息</p>
<p><code>git tag -a + &lt;tagname&gt; -m + &lt;tagDescription&gt;</code> 创建带有说明的标签，用-a指定标签名，-m指定说明文字</p>
<p><code>it tag -s + &lt;tagname&gt; -m + &lt;tagDescription&gt;</code> 通过-s用私钥签名一个标签，使用PGP签名，不过必须安装gpg(GunPG)，没有gpg秘钥对会报错</p>
<p><code>git tag -d + &lt;tagname&gt;</code>         删除标签</p>
<p><code>git push origin + &lt;tagname&gt;</code>     推送某个标签到远程</p>
<p><code>git push origin -- tags</code>            一次性推送全部尚未推送到远程的本地标签</p>
<p><code>git push origin :refs/tags/&lt;tagname&gt;</code> 删除一个远程标签，登陆远程可查看删除标签效果。</p>
<p>示例：删除已经推送到远程的的标签，需要首先删除本地标签，然后从远程删除，使用</p>
<p><code>git push origin :refs/tags/标签名</code></p>
<p>小结：</p>
<p>1.默认标签是打在最新提交的commit上的</p>
<p>2.查看标签列表时，标签不是按照时间顺序列出的。</p>
<p>3.创建标签都会只存储到本地，不会自动推送到远程，所以打错的标签可以在本地安全删除</p>
<p>八.使用GItHub</p>
<p>1.在GitHub上，可以任意的Fork开源仓库，相当于是拷贝到自己远程仓库中</p>
<p>2.我们拥有的Fork后仓库的读写权限</p>
<p>3.可以推送pull request给官方仓库来贡献代码</p>
<p>九.自定义Git</p>
<p>1.忽略特殊文件</p>
<p>在我们使用Git的时候，有时候某些文件不得不放在git目录下，但是它们又不能被提交(可能是一些程序执行生成的中间文件)。这时候需要用到忽略文件。</p>
<p>原理：编辑.gitignore文件，将其放在版本库里并提交到Git。.gitignore文件中记录需要忽略提交的文件类型。</p>
<p>我们无需自己从头编写.gitignore文件，查看Github已经为我们准备好的配置文件，再根据自己的需要修改忽略文件即可。</p>
<p>2.配置别名</p>
<p>通过对一些复杂的命令指定别名，可以更加方便的使用Git</p>
<p><code>git config -- global alias.st status</code>       指定别名：查看版本状态</p>
<p><code>git config -- global alias.ci commit</code>       指定别名：提交版本库</p>
<p><code>git config -- global alias.co checkout</code>      指定别名：切换分支</p>
<p><code>git config -- global alias.br branch</code>       指定别名：查看分支</p>
<p><code>git config -- global alias.last ‘log -1’</code>   指定别名：显示最后一次提交信息</p>
<p>示例：设置别名后可以直接使用git st 查看当前版本状态</p>
<p>补充：git config –global alias.lg “log –color –graph –pretty=format:</p>
<pre><code>&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) 

 %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</code></pre><p>查看详细log</p>
<p>参数说明：</p>
<p>– global</p>
<p>1.该参数是全局参数，配置Git的时候，加上–global是针对当前用户起作用，如果不加就只对当前的仓库起作用。</p>
<p>2.配置的别名被保存在配置文件中，每个仓库的git配置文件都放在.git/config文件中，别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。</p>
<p>3.当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：</p>
<p>//查看配置文件的命令</p>
<p>cat .git/config 查看当前仓库的Git配置文件</p>
<p>cat .gitconfig  查看当前用户主目录下隐藏的配置文件</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

